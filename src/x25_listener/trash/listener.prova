/*
 * $Id: listener.prova,v 1.1.1.1 1998/11/18 15:03:27 paul Exp $
 * 
 * Project : PX25 - Router per Autorizzazioni POS
 *
 * Module: x25_listener
 *
 * Contents: listen for incoming x25 calls
 *
 * Author(s): C.U. S.r.l - P.Borile, G. Priveato
 *
 * $Log: listener.prova,v $
 * Revision 1.1.1.1  1998/11/18 15:03:27  paul
 * Guardian : x25 Pos router
 *
 *
 */

static char rcsid[] = "$Id: listener.prova,v 1.1.1.1 1998/11/18 15:03:27 paul Exp $";

/*  System include files                        */

#include	<stdio.h>
#include	<x25.h>
#include	<neterr.h>

/*  Project include files                       */

#include	"px25_globals.h"
#include	"debug.h"
#include	"errlog.h"  

/*  Module include files                        */

/*  Extern functions used                       */

/*  Local functions used                       */

void	get_command_line();
void	x25_listener_usage();

/*  Extern data used                            */

/*  Local constants                             */

#define	OPTS	"d:p:"

/*  Local types                                 */

/*  Local macros                                */

#define	X25_ADLEN	(X25_ADDRLEN+X25_ADDREXT+2)

/*  Local data                                  */

struct	x25data	facility;
struct	x25data	user_data;

char	dest_addr[X25_ADLEN];
char	source_addr[X25_ADLEN];
char	*inbuf;
int		cid;
int		info = 0;

int	debuglevel = -1;
static	int	port = -1;

main(argc, argv)
int	argc;
char	**argv;
{
	char	msg[ENETMSGLEN];
	char	dummy[BUFSIZ];
	/*
	 * now only listen and accept calls generated by pos
	 */

	set_signals();

	get_command_line(argc, argv);

	/*
	 * Initialize x25 toolkit
	 */

	if ( x25init(0) < 0 )
	{
		x25perror("x25init()");
		exit();
	}
		
	x25version(msg);
	printf("%s\n", msg);

	/*
	 * Allocate a buffer
	 */

	if (( inbuf = x25alloc(X25_DATA_PACKET_SIZE)) == NULL)
	{
		x25perror("\nx25alloc");
		exit(1);
	}

	/*
	 * now listen on the specified port
	 */

	printf("Port %d, Going to listen ....", port);
	fflush(stdout);
	
	/* facility.xd_len = 0; */

	strcpy(source_addr, "");
	strcpy(dest_addr, "");
	info = XI_QBIT;

	if ( x25xlisten(&cid, X25WAIT, port, info, &facility, &user_data,
						 dest_addr, source_addr, X25NULLFN) < 0)
	{
		printf("x25xlisten: error\n");
	}

	printf("... done\n");

	if ( user_data.xd_len > 0 )
	{
		memcpy(dummy, user_data.xd_data, user_data.xd_len);
		dummy[user_data.xd_len] = '\0';
		printf("User data received! : %s\n", dummy);
	}

	printf("Strike any key to accept\n");

	getchar();

	if ( x25accept(&cid, info, NULL, NULL,
					dest_addr, source_addr, X25NULLFN) < 0)
	{
		printf("x25accept() - error\n");
		exit(1);
	}
	
	getchar();

	x25exit();
}

/*
 *
 *  Procedure: get_command_line
 *
 *  Parameters: argc, argv
 *
 *  Description: parse command line
 *
 *  Return: none
 *
 */

void	get_command_line(argc, argv)
int	argc;
char	**argv;
{
	int	fatal = 0;
	int	c;

	extern char *optarg;

	while ((c = getopt(argc, argv, OPTS)) !=EOF)
	{
		switch(c)
		{
			case	'd':
				debuglevel  =   atoi(optarg);
				break;

			case	'p':
				port = atoi(optarg);
				break;

			default:
				printf("%s : invalid flag.\n", argv[0]);
				x25_listener_usage(argc, argv);
				exit(FAILURE);
		}
	}

#ifdef DEBUG
	if ( debuglevel == -1 ) fatal++;
#endif

	if ( port == -1 ) fatal++;

	if ( fatal )
	{
		x25_listener_usage(argc, argv);
		exit(FAILURE);
	}
}


/*
 *
 *  Procedure: x25_listener_usage
 *
 *  Parameters: argc, argv
 *
 *  Description: obvious ?
 *
 *  Return: ah!
 *
 */

void	x25_listener_usage(argc, argv)
int	argc;
char	**argv;
{
#ifdef	DEBUG
	printf("Usage: %s -d<debuglevel> -p<port>\n",argv[0]);
#else
	printf("Usage: %s -p<port>\n",argv[0]);
#endif
}
